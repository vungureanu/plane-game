<html>
	<head>
		<title>Three Test</title>
		<style>
			body { margin: 0; }
			/*canvas { width: 100%; height: 100% }
		</style>
	</head>
	<body>
		<script src="/socket.io/socket.io.js"></script>
		<script src="js/three.js"></script>
		<script>
			const trail_material = new THREE.MeshBasicMaterial({
					color: 0x0000ff,
					side : THREE.DoubleSide,
					transparent : true,
					opacity: 0.5
				});
			const TRAIL_LENGTH = 100;
			var socket = io();
			const SPEED = 0.1;
			const SEND_INTERVAL = 100; // Milliseconds between successive send operations
			// Distance of mouse away from center, as fraction of the canvas's width or height
			var new_coords = { left : new THREE.Vector3(0, 0, 0), right : THREE.Vector3(0, 0, 0) };
			var old_coords = { left : new THREE.Vector3(0, 0, 0), right : THREE.Vector3(0, 0, 0) };
			var x_frac = 0;
			var y_frac = 0;
			var players = {}; // State (spatial coordinates and orientation) of all other players
			var contrails = []; // Player's own contrails
			var turn = 0;
			var own_id;

			function draw_plane( coords ) {
				var plane = new THREE.Group();
				plane.name = "plane";
				var geometry = new THREE.BoxGeometry( 1, 1, 20 );
				var material = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
				var cube = new THREE.Mesh( geometry, material );
				var geometry = new THREE.SphereGeometry( 2, 32, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0xff00ff} );
				var sphere = new THREE.Mesh( geometry, material );
				var geometry = new THREE.BoxGeometry( 10, 1, 1 );
				var material = new THREE.MeshBasicMaterial( { color: 0x0000ff } );
				var cross = new THREE.Mesh( geometry, material );
				var geometry = new THREE.SphereGeometry( 1, 32, 32 );
				var material = new THREE.MeshBasicMaterial( {color: 0xff0000} );
				var left_guide = new THREE.Mesh( geometry, material );
				left_guide.name = "left guide";
				var right_guide = new THREE.Mesh( geometry, material );
				right_guide.name = "right guide";
				sphere.position.set( 0, 0, 10 );
				cross.position.set( 0, 0, 0 );
				left_guide.position.set( 5, 0, 0 );
				right_guide.position.set( -5, 0, 0 );
				left_guide.old_coords = left_guide.getWorldPosition();
				right_guide.old_coords = right_guide.getWorldPosition();
				plane.add(cube);
				plane.add(sphere);
				plane.add(cross);
				plane.add(left_guide);
				plane.add(right_guide);
				return plane;
			}

			function add_trail( player, new_coords ) {
				var triangleGeometry = new THREE.Geometry();
				triangleGeometry.vertices[0] = player.old_coords.left;
				triangleGeometry.vertices[1] = player.old_coords.right;
				triangleGeometry.vertices[2] = new_coords.left;
				triangleGeometry.vertices[3] = new_coords.right;
				triangleGeometry.faces.push( new THREE.Face3(0, 1, 2) );
				triangleGeometry.faces.push( new THREE.Face3(1, 2, 3) );
				var square = new THREE.Mesh( triangleGeometry, trail_material );
				if (player.trail[player.trail_index] != undefined) {
					scene.remove(player.trail[player.trail_index]);
				}
				console.log(player.trail[player.trail_index], player.trail_index);
				player.trail[player.trail_index] = square;
				player.trail_index = (player.trail_index + 1) % TRAIL_LENGTH;
				scene.add( square );
				player.old_coords = new_coords;
			}

			var scene = new THREE.Scene();
			var camera = new THREE.PerspectiveCamera( 75, window.innerWidth/window.innerHeight, 0.1, 1000 );
			camera.position.z = -25;
			camera.position.y = 5;
			camera.lookAt(0, 0, 0);
			var renderer = new THREE.WebGLRenderer();
			renderer.setSize( window.innerWidth, window.innerHeight );
			document.body.appendChild( renderer.domElement );

			
			/* EARTH */
			var geometry = new THREE.SphereGeometry( 50, 5, 5 );
			var material = new THREE.MeshBasicMaterial( { color: 0x00ffff } );
			var earth1 = new THREE.Mesh( geometry, material );
			earth1.position.set(0, 80, 0);
			var earth2 = new THREE.Mesh( geometry, material );
			earth2.position.set(0, -80, 0);
			var earth3 = new THREE.Mesh( geometry, material );
			earth3.position.set(80, 0, 0);
			var earth4 = new THREE.Mesh( geometry, material );
			earth4.position.set(-80, 0, 0);
			var earth5 = new THREE.Mesh( geometry, material );
			earth5.position.set(0, 0, 80);
			var earth6 = new THREE.Mesh( geometry, material );
			earth6.position.set(0, 0, -80);
			scene.add(earth1);
			scene.add(earth2);
			scene.add(earth3);
			scene.add(earth4);;
			scene.add(earth6);

			var plane_and_camera = new THREE.Group();
			var own_plane = draw_plane();
			plane_and_camera.add(own_plane);
			plane_and_camera.add(camera);
			scene.add(plane_and_camera);

			var animate = function () {
				requestAnimationFrame( animate );
				renderer.render(scene, camera);
			};

			//animate();
			window.addEventListener('keypress', function(e) {
				if (e.keyCode == 65 || e.keyCode == 97) {
					turn = -1;
				}
				if (e.keyCode == 68 || e.keyCode == 100) {
					turn = 1;
				}
			});
			window.addEventListener('keyup', function(e) {
				if (e.keyCode == 65 || e.keyCode == 97 || e.keyCode == 68 || e.keyCode == 100) {
					turn = 0;
				}
			});
			window.addEventListener('mousemove', function(e) {
				x_frac = (e.clientX - window.innerWidth / 2) / window.innerWidth;
				y_frac = (e.clientY - window.innerHeight / 2) / window.innerHeight;
			});
			window.addEventListener('resize', function() {
				renderer.setSize( window.innerWidth, window.innerHeight );
				camera.aspect = window.innerWidth / window.innerHeight;
				camera.updateProjectionMatrix();
			});

			// CLIENT-SERVER COMMUNICATION

			function send_data() {
				socket.emit("status", {
					id : own_id,
					x_frac : x_frac,
					y_frac : y_frac,
					turn : turn,
					click : false
				});
			}

			setInterval(send_data, SEND_INTERVAL);

			socket.on("update", function(status) {
				var outer_rot = new THREE.Euler(status.outer_rot._x, status.outer_rot._y, status.outer_rot._z, status.outer_rot._order);
				var inner_rot = new THREE.Euler(status.inner_rot._x, status.inner_rot._y, status.inner_rot._z, status.inner_rot._order);
				var player = players[status.id];
				player.plane_container.setRotationFromEuler(outer_rot);
				player.plane.setRotationFromEuler(inner_rot);
				player.plane_container.position.set(status.pos.x, status.pos.y, status.pos.z);
				var new_coords = {
					left : new THREE.Vector3( status.trail.left.x, status.trail.left.y, status.trail.left.z ),
					right : new THREE.Vector3( status.trail.right.x, status.trail.right.y, status.trail.right.z )
				};
				add_trail(player, new_coords);
				renderer.render(scene, camera);
			});

			socket.on("id", function(id) {
				players[id] = {
					plane_container : plane_and_camera,
					plane : own_plane,
					trail : [],
					trail_index : 0,
					old_coords : {
						left : own_plane.getObjectByName("left guide").getWorldPosition(),
						right : own_plane.getObjectByName("right guide").getWorldPosition()
					}
				};
				own_id = id;
			});

			socket.on("add", function(status) {
				var plane = draw_plane();
				var plane_container = new THREE.Group();
				plane_container.add(plane);
				plane_container.position.set(status.pos.x, status.pos.y, status.pos.z);
				var outer_rot = new THREE.Euler(status.outer_rot._x, status.outer_rot._y, status.outer_rot._z, status.outer_rot._order);
				var inner_rot = new THREE.Euler(status.inner_rot._x, status.inner_rot._y, status.inner_rot._z, status.inner_rot._order);
				plane_container.setRotationFromEuler(outer_rot);
				plane.setRotationFromEuler(inner_rot);
				players[status.id] = {
					plane_container : plane_container,
					plane : plane,
					trail : [],
					trail_index : 0,
					old_coords : {
						left : plane.getObjectByName("left guide").getWorldPosition(),
						right : plane.getObjectByName("right guide").getWorldPosition()
					}
				};
				scene.add(plane_container);
			});
		</script>
	</body>
</html>